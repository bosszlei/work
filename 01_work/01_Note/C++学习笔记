1.函数重载中，要求参数列表不相同（可能是参数类型不相同，也可能是参数个数不相同），但是函数名必须相同。

2.将using namespace std; 直接声明在所有函数外部，这样虽然使用方便，但在中大型项目开发中是不被推荐的，这样做增加了命名冲突的风险，
我们推荐在函数内部声明 using namespace std;
命名空间实际上是为了防止多文件中的类、函数、变量命名冲突的问题。

3.在虚函数的后面写上 = 0，则这个函数为纯虚函数。包含纯虚函数的类叫做抽象类（也叫接口类），抽象类不能实例化出对象。派生类继承后也不能实例化出对象。
  只有重写纯虚函数，派生类才能实例化出对象。纯虚函数规范了派生类必须重写，另外纯虚函数更体现了接口继承。
        1)虚函数表本质是一个存虚函数指针的指针数组，这个数组最后面放了一个nullptr

4.派生类的虚表生成：
    （1）先将基类中的虚表内容拷贝一份到派生类虚表中；
    （2）如果派生类重写了基类中的某个虚函数，用派生类自己的虚函数覆盖虚表中基类的虚函数；
    （3）派生类自己新增加的虚函数按其在派生类中的声明次序增加到派生类的虚表的最后。

5.动态绑定与静态绑定：
    a. 静态绑定又称为前期绑定（早绑定），在程序编译期间确定了程序的行为，也称为静态多态 ，例如：函数重载。
    b. 动态绑定又称为后期绑定（晚绑定），是在程序运行期间，根据具体拿到的类型确定程序的具体行为，调用具体的函数，也称为动态多态。

6.容器
    vector说明：
        · vector是向量类型，可以容纳许多类型的数据，因此也被称为容器
        · (可以理解为动态数组，是封装好了的类）
        · 进行vector操作前应添加头文件#include <vector>
        
    vector容器和list容器区别：
        1）vector容器底层用数组实现，list容器底层用双向链表实现
    
    迭代器，每个标准容器都提供有一个名为begin（）的操作函数，可返回一个iterator，指向第一个元素。
    另一个名为end（）的操作函数会返回一个iterator，指向最后一个元素的下一位置
    迭代器：左开右闭类型，[ )

7.成员初始化列表主要用于将参数传给成员类对象的构造函数。

8.析构函数主要用来释放在构造函数中或对象生命周期中分配的资源。由于析构函数的参数列表为空，所以析构函数不能被重载。

9.重载和重写：
    重载:是指同一可访问区内被声明的几个具有不同参数列（参数的类型，个数，顺序不同）的同名函数，根据参数列表确定调用哪个函数，重载不关心函数返回类型。
    重写：是指派生类中存在重新定义的函数。其函数名，参数列表，返回值类型，所有都必须同基类中被重写的函数一致。
        只有函数体不同（花括号内），派生类调用时会调用派生类的重写函数，不会调用被重写函数。重写的基类中被重写的函数必须有virtual修饰。

    区别：
        （1）范围区别：重写和被重写的函数在不同的类中，重载和被重载的函数在同一类中。

        （2）参数区别：重写与被重写的函数参数列表一定相同，重载和被重载的函数参数列表一定不同。

        （3）virtual的区别：重写的基类函数必须要有virtual修饰，重载函数和被重载函数可以被virtual修饰，也可以没有。

10.代码格式规范
    空格的使用

    必须有一个空格的位置：
        - 二元操作符，包括赋值符号的两侧
        - 关键字和圆括号之间
        - 不在行末的逗号和分号后
        - 表示继承和初始化列表的冒号两侧
        - 只有一行语句的函数体的花括号与语句之间
        - delete和[]之间，以及[]和变量名之间

    不能有空格的位置：
        - 逗号和分号前
        - 圆括号和尖括号内侧
        - 函数名和圆括号之间
        - 一元操作符和操作数之间
        - 空的圆括号和花括号中
        - 表示初始化列表的花括号和值之间
        - 范围操作符（::）两侧
        - #号右侧

11.线程同步的方式
    线程同步：线程同步是指多线程通过特定的设置（如互斥量，事件对象，临界区）来控制线程之间的执行顺序（即所谓的同步）
        也可以说是在线程之间通过同步建立起执行顺序的关系，如果没有同步，那线程之间是各自运行各自的！

    线程互斥：线程互斥是指对于共享的进程系统资源，在各单个线程访问时的排它性。当有若干个线程都要使用某一共享资源时，
        任何时刻最多只允许一个线程去使用，其它要使用该资源的线程必须等待，直到占用资源者释放该资源。线程互斥可以看成是一种特殊的线程同步

    多线程：多线程是程序设计的逻辑层概念，它是进程中并发运行的一段代码。多线程可以实现线程间的切换执行

    异步和多线程并不是一个同等关系,异步是最终目的,多线程只是我们实现异步的一种手段。
    异步是当一个调用请求发送给被调用者,而调用者不用等待其结果的返回而可以做其它的事情。实现异步可以采用多线程技术或则交给另外的进程来处理。

    时间局部性:一个指令被执行了，在不久的将来，可能被再次执行；
    空间局部性：一个指令的存储单元被访问，那么它附近的单元也将很快被访问；
    程序的局部性原理是虚拟内存技术的前提

12.事务的特性（ACID）
    原子性(Atomicity)、一致性(Consistency)、隔离性(Isolation) 、 持续性(Durability)

13.死锁：
    产生死锁的必要条件：互斥条件；请求和保持条件；不剥夺条件；环路等待条件
    在死锁的条件中，不剥夺条件是指进程已获得的资源只能在使用完时由自己释放。
    在死锁的条件中，互斥条件是指在一段时间内，某资源只能被一进程占用。
    资源的按序分配法是摒弃死锁条件中的环路等待条件来预防死锁的发生。
    现代操作系统产生死锁的条件中，互斥条件是不能被摒弃来预防死锁的发生。
    抢占式进程调度方式基于的主要原则：优先权原则；短进程优先原则；时间片原则。
    通常采用解除死锁的两种方法：剥夺资源；撤销进程；
    产生进程死锁的原因可归结为两点：竞争资源；进程间推进顺序非法；

14.进程和线程
    进程，是并发执行的程序在执行过程中分配和管理资源的基本单位，是一个动态概念，竞争计算机系统资源的基本单位。每一个进程都有一个自己的地址空间

Hash冲突的四种解决方法：
    1）开放定址法
    2）再Hash法
    3）链地址法
    4）建立公共溢出区












